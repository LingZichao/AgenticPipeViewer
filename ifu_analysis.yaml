# Advanced IFU Analysis Configuration with Complex Conditions
# 展示复杂条件判断的能力

fsdb_file: "work_force/novas.fsdb"
clock_signal: "tb.clk"

# Signal base paths
_signal_base: &ifu_base "tb.x_soc.x_cpu_sub_system_axi.x_rv_integration_platform.x_cpu_top.x_ct_top_0.x_ct_core.x_ct_ifu_top"

tasks:
  # ============================================================================
  # Example 1: Simple condition (array format)
  # ============================================================================
  - name: "Basic Valid Count"
    mode: "count"
    condition: [[*ifu_base, ".biu_ifu_rd_data_vld"], "==", 1]
  
  # ============================================================================
  # Example 2: Compound AND condition (multiple signals must all be true)
  # ============================================================================
  - name: "Valid AND Grant Together"
    mode: "count"
    condition:
      $and:
        - [[*ifu_base, ".biu_ifu_rd_data_vld"], "==", 1]
        - [[*ifu_base, ".biu_ifu_rd_grnt"], "==", 1]
  
  # ============================================================================
  # Example 3: OR condition (any condition is true)
  # ============================================================================
  - name: "Request OR Grant Active"
    mode: "count"
    condition:
      $or:
        - [[*ifu_base, ".ifu_biu_rd_req"], "==", 1]
        - [[*ifu_base, ".biu_ifu_rd_grnt"], "==", 1]
  
  # ============================================================================
  # Example 4: Range check (value between min and max)
  # ============================================================================
  - name: "Data in Normal Range"
    mode: "count"
    condition:
      $and:
        - [[*ifu_base, ".biu_ifu_rd_data"], ">=", "32'h1000"]
        - [[*ifu_base, ".biu_ifu_rd_data"], "<=", "32'h2000"]
  
  # ============================================================================
  # Example 5: NOT condition (negation)
  # ============================================================================
  - name: "Not in Idle State"
    mode: "count"
    condition:
      $not: [[*ifu_base, ".ifu_state"], "==", "3'b000"]
  
  # ============================================================================
  # Example 6: Bit field checking (bitwise AND with mask)
  # ============================================================================
  - name: "Check Specific Bits"
    mode: "count"
    # Bitwise: (signal & mask) == value
    condition:
      $and:
        - [[*ifu_base, ".control_flags"], "&", "8'hF0"]
        - [[*ifu_base, ".control_flags"], "==", "8'h30"]
  
  # ============================================================================
  # Example 7: Complex nested condition (real-world scenario)
  # Valid request with no grant, OR grant with specific data pattern
  # ============================================================================
  - name: "Complex IFU Stall Detection"
    mode: "count"
    condition:
      $or:
        # Case 1: Request without grant (stall)
        - $and:
            - [[*ifu_base, ".ifu_biu_rd_req"], "==", 1]
            - [[*ifu_base, ".biu_ifu_rd_grnt"], "==", 0]
        # Case 2: Grant but data valid delayed
        - $and:
            - [[*ifu_base, ".biu_ifu_rd_grnt"], "==", 1]
            - [[*ifu_base, ".biu_ifu_rd_data_vld"], "==", 0]
  
  # ============================================================================
  # Example 8: Data capture with complex trigger
  # ============================================================================
  - name: "Capture Valid Transactions"
    mode: "capture"
    condition:
      $and:
        - [[*ifu_base, ".biu_ifu_rd_data_vld"], "==", 1]
        - [[*ifu_base, ".biu_ifu_rd_data"], "!=", 0]

    capture:
      - [*ifu_base, ".biu_ifu_rd_data"]
      - [*ifu_base, ".biu_ifu_rd_grnt"]
      - [*ifu_base, ".ifu_state"]
      
    output:
      format: "hex"
      file: "complex_capture.csv"
  
  # ============================================================================
  # Example 9: Expression-based condition (for maximum flexibility)
  # 直接使用fsdbreport表达式语法
  # ============================================================================
  - name: "Custom Expression"
    mode: "count"
    condition:
      $expr: "(/tb/x_soc/x_cpu/.../biu_ifu_rd_data_vld==1)&&((/tb/.../biu_ifu_rd_data&32'hFFFF0000)==32'h10000000)"
  
  # ============================================================================
  # Example 10: Signal-to-Signal Comparison
  # Array format supports both signal and constant comparisons
  # ============================================================================
  - name: "Request Address Matches Response Address"
    mode: "count"
    condition:
      $and:
        # Both addresses are valid and equal
        - [[*ifu_base, ".ifu_req_addr"], "==", [*ifu_base, ".biu_resp_addr"]]
        - [[*ifu_base, ".biu_ifu_rd_data_vld"], "==", 1]
  
  # ============================================================================
  # Example 11: Mixed Signal and Constant Comparisons
  # ============================================================================
  - name: "Write Address in Read Address Range"
    mode: "count"
    condition:
      $and:
        # Write address >= read base address
        - [[*ifu_base, ".write_addr"], ">=", [*ifu_base, ".read_base_addr"]]
        # Write address < read base + size
        - [[*ifu_base, ".write_addr"], "<", [*ifu_base, ".read_end_addr"]]
    
    logging: 
        [IFU fetch, PC={ifu_pc:#x}, Inst={ifu_inst:#x} at time {__time__}]

output:
  directory: "temp_reports"
  keep_reports: true  # Keep for debugging complex conditions

# Notes:
# 1. Array format for simple conditions (RECOMMENDED):
#    - Format: [left, op, right]
#    - Example: ["signal", "==", 1] or ["signal1", ">=", "signal2"]
#    - Auto-concatenation: If left or right is an array, it will be joined
#      Example: [[*base, ".signal"], "==", 1] → "base.signal" == 1
#
# 2. MongoDB-style logical operations (no nested 'condition' field!):
#    - AND: $and: [cond1, cond2, ...]
#    - OR: $or: [cond1, cond2, ...]
#    - NOT: $not: single_cond
#    - Expression: $expression: "raw fsdbreport syntax"
#
# 3. Comparison operators (use symbols):
#    ==, !=, >, <, >=, <=
#
# 4. Bitwise operators (also in array format):
#    &, |, ^
#    Example: [signal, "&", "8'hF0"] for bitwise AND
#
# 5. Conditions can be nested arbitrarily:
#    $or:
#      - $and:
#          - [sig1, "==", 1]
#          - [sig2, "==", 0]
#      - [sig3, "==", 1]
#
# 6. Both signal-to-signal and signal-to-constant comparisons supported:
#    - Signal-to-constant: [signal, "==", 1]
#    - Signal-to-signal: [signal1, "==", signal2]
#    - With concatenation: [[*base, ".sig1"], "==", [*base, ".sig2"]]
#
# 7. For capture tasks:
#    output: {format: "hex", file: "name.csv"}
